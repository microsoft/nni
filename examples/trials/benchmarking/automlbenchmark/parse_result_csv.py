# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

import pandas as pd
import sys
import matplotlib.pyplot as plt


def generate_perf_report(result_file_name):
    """
    Generate a performance report. 
    The input result_file_name should be the path of the "results.csv" generated by automlbenchmark.
    This function outputs a formatted report named "performances.txt" in the "reports/" directory 
    located in the same parent directory as "results.csv".
    """
    result = pd.read_csv(result_file_name)
    task_ids = result['id'].unique()
    keep_parameters = ['framework', 'constraint', 'result', 'metric', 'params', 'utc', 'duration'] + list(result.columns[16:])    

    with open(result_file_name.replace('results.csv', 'reports/performances.txt'), 'w') as out_f:
        for task_id in task_ids:
            task_results = result[result['id'] == task_id]
            task_name = task_results.task.unique()[0]
            out_f.write("====================================================\n")
            out_f.write("Task ID: {}\n".format(task_id))
            out_f.write("Task Name: {}\n".format(task_name))
            folds = task_results['fold'].unique()
            for fold in folds:
                out_f.write("Fold {}:\n".format(fold))
                res = task_results[task_results['fold'] == fold][keep_parameters]
                out_f.write(res.to_string())
                out_f.write('\n')

            out_f.write('\n')   


def generate_graphs(result_file_name):
    """
    Generate graphs describing performance statistics.
    The input result_file_name should be the path of the "results.csv" generated by automlbenchmark.
    For each task, this function outputs two graphs in the "reports/" directory located in the same 
    parent directory as "results.csv".
    The graph named task_foldx_1.jpg summarizes the best score each tuner gets after n trials. 
    The graph named task_foldx_2.jpg summarizes the score each tuner gets in each trial. 
    """
    result = pd.read_csv(result_file_name)
    scorelog_dir = result_file_name.replace('results.csv', 'scorelogs/')
    output_dir = result_file_name.replace('results.csv', 'reports/') 
    task_ids = result['id'].unique()
    for task_id in task_ids:
        task_results = result[result['id'] == task_id]
        task_name = task_results.task.unique()[0]
        folds = task_results['fold'].unique()        

        for fold in folds:            
            # load scorelog files
            trial_scores, best_scores = [], []
            tuners = list(task_results[task_results.fold == fold]['framework'].unique())
            for tuner in tuners:
                scorelog_name = '{}_{}_{}.csv'.format(tuner.lower(), task_name, fold)
                intermediate_scores = pd.read_csv(scorelog_dir + scorelog_name)
                best_scores.append([tuner, list(intermediate_scores['best_score'])])
                trial_scores.append([tuner, list(intermediate_scores['trial_score'])])

            # generate the best score graph
            plt.figure(figsize=(16, 8))
            for tuner, score in best_scores:
                plt.plot(score, label=tuner)
            plt.title('{} Fold {}'.format(task_name, fold))
            plt.xlabel("Number of Trials")
            plt.ylabel("Best Score")        
            plt.legend()
            plt.savefig(output_dir + '{}_fold{}_1.jpg'.format(task_name, fold))
            plt.close()

            # generate the trial score graph
            plt.figure(figsize=(16, 8))
            for tuner, score in trial_scores:
                plt.plot(score, label=tuner)
            plt.title('{} Fold {}'.format(task_name, fold))
            plt.xlabel("Trial Number")
            plt.ylabel("Trial Score")        
            plt.legend()
            plt.savefig(output_dir + '{}_fold{}_2.jpg'.format(task_name, fold))
            plt.close()

            
def main():
    if len(sys.argv) != 2:
        print("Usage: python parse_result_csv.py <result.csv file>")
        exit(0)
    generate_perf_report(sys.argv[1])
    generate_graphs(sys.argv[1])
    

if __name__ == '__main__':
    main()
