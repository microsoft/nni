# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

from __future__ import annotations

__all__ = [
    'uid', 'reset_uid',
    'NoContextError', 'ContextStack', 'get_current_context',
    'label_scope', 'auto_label',
]

import logging
from collections import defaultdict
from typing import Any

_last_uid = defaultdict(int)

_logger = logging.getLogger(__name__)


def uid(namespace: str = 'default') -> int:
    """Global counter for unique id. Not thread-safe."""
    _last_uid[namespace] += 1
    return _last_uid[namespace]


def reset_uid(namespace: str = 'default') -> None:
    """Reset counter for a specific namespace."""
    _last_uid[namespace] = 0


class NoContextError(Exception):
    """Exception raised when context is missing."""
    pass


class ContextStack:
    """
    This is to maintain a globally-accessible context environment that is visible to everywhere.

    To initiate::

        with ContextStack(namespace, value):
            ...

    Inside the context, you can access the nearest value put into ``with``::

        get_current_context(namespace)

    Notes
    -----
    :class:`ContextStack` is not multi-processing safe. Also, the values will get cleared for a new process.
    """

    _stack: dict[str, list] = defaultdict(list)

    def __init__(self, key: str, value: Any):
        self.key = key
        self.value = value

    def __enter__(self):
        self.push(self.key, self.value)
        return self

    def __exit__(self, *args, **kwargs):
        self.pop(self.key)

    @classmethod
    def push(cls, key: str, value: Any):
        cls._stack[key].append(value)

    @classmethod
    def pop(cls, key: str) -> Any:
        if not cls._stack[key]:
            raise NoContextError(f'Context with key {key} is empty.')
        return cls._stack[key].pop()

    @classmethod
    def top(cls, key: str) -> Any:
        if not cls._stack[key]:
            raise NoContextError(f'Context with key {key} is empty.')
        return cls._stack[key][-1]

    @classmethod
    def stack(cls, key: str) -> list:
        return list(cls._stack[key])


def get_current_context(key: str) -> Any:
    return ContextStack.top(key)


_LABEL_NAMESPACE_CONTEXT_KEY = 'label_namespace'


class label_scope:
    """
    To support automatic labeling of mutables.

    Labels are named like a file-system. The analogy here is that:
    scope is like a directory, and label is like a file.
    The label name is like a file name. It can't contain slash (``/``) or underscore (``_``).
    The scope name is like a directory name. It also can't contain ``/`` or ``_``.
    When we refer to a "label", we will usually use the full name, which is like an absolute file path.

    :class:`label_scope` is usually jointly used with :func:`auto_label`,
    where :class:`label_scope` is used to generate the "scope" (directory) part,
    and :func:`auto_label` is used to generate the "name" (file) part.
    A :class:`label_scope` can be entered, and then :func:`auto_label` can be called inside.
    The labels as well as scopes generated inside can be automatically named with natural integers starting from 1
    (see examples below), and we guarantee the generation of labels to be reproducible.
    It can also be naturally nested.

    :class:`label_scope` is NOT thread-safe. The behavior is undefined if multiple threads are
    trying to enter the scope at the same time.

    :class:`label_scope` is implemented based on :class:`ContextStack`.

    Parameters
    ----------
    scope_name
        Name of current scope. If not specified, it will be generated by the parent scope.
        If the parent scope is not found, the scope name will be ``param`` by default.

    Examples
    --------
    >>> with label_scope('model'):
    ...     label1 = auto_label()       # model/1
    ...     label2 = auto_label()       # model/2
    ...     label3 = auto_label('foo')  # model/foo
    ...     with label_scope():
    ...         label4 = auto_label()   # model/3/1
    ...         label5 = auto_label()   # model/3/2
    ...     with label_scope('another'):
    ...         label6 = auto_label()   # model/another/1
    ...     with label_scope('model'):
    ...         label7 = auto_label()   # model/model/1
    >>> with label_scope('model'):
    ...     label8 = auto_label()       # model/1, because the counter is reset
    >>> with label_scope():
    ...     label9 = auto_label()       # param/1
    """

    def __init__(self, scope_name: str | None = None, *, _path: list[str] | None = None):
        if scope_name is not None:
            _validate_label_name(scope_name)

        # scope_name is not assigned at this point.
        # It will be assigned later when "with" is entered.
        self.scope_name = scope_name

        # The full "path" of current scope.
        # It should also contain the part after the last ``/``.
        # It should be avoided from setting by users.
        self.path = _path

        if self.path:
            assert self.path[-1] == self.scope_name, f'Path {self.path} does not match scope name {self.scope_name}'

    def __enter__(self):
        # Enter the label namespace resets the counter associated with the namespace.
        #
        # It also pushes itself into the stack, so as to support nested namespace.
        # For example, currently the top of stack is ['foo', 'bar'], and ['foo', 'bar', '3'] is used,
        # the next thing up is ['foo', 'bar', '4'].
        # `reset_uid` to count from zero for "foo/bar/4"
        parent_context = label_scope.current()
        if parent_context is not None:
            if self.scope_name is None:
                self.scope_name = parent_context.next_label()
            assert parent_context.path is not None
            self.path = parent_context.path + [self.scope_name]
        else:
            if self.scope_name is None:
                self.scope_name = 'param'
            self.path = [self.scope_name]
        ContextStack.push(_LABEL_NAMESPACE_CONTEXT_KEY, self)
        reset_uid(self.absolute_scope)
        return self

    def __exit__(self, *args, **kwargs):
        ContextStack.pop(_LABEL_NAMESPACE_CONTEXT_KEY)

    @property
    def absolute_scope(self) -> str:
        """The full name of current namespace.

        For example, ``model/cell/2``.
        """
        if self.path is None:
            raise ValueError(f'label_scope "{self.scope_name}" is not entered yet.')
        return '/'.join(self.path)

    def __repr__(self):
        return f'label_scope({self.absolute_scope!r})'

    def next_label(self) -> str:
        """Generate the "name" part"""
        return str(uid(self.absolute_scope))

    @staticmethod
    def current() -> label_scope | None:
        """Fetch the nearest label scope activated by ``with``.

        If label scope is never used, or we are currently within no with-block,
        return none.

        Examples
        --------
        >>> with label_scope() as scope1:
        ...     # somewhere in the middle of the code.
        ...     label_scope.current()     # Return scope1
        """
        try:
            return ContextStack.top(_LABEL_NAMESPACE_CONTEXT_KEY)
        except NoContextError:
            return None

    @staticmethod
    def global_() -> label_scope:
        """Fetch the global label scope.

        This label scope can be created on-the-fly and can live without the with-blocks.
        """
        return label_scope('global', _path=['global'])


def auto_label(label: str | None = None, scope: label_scope | None = None) -> str:
    """Automatically generate a formatted and reproducible label.

    In case ``label`` is not set, the label name will use the uid sequence of ``scope``.
    If ``scope`` is not set, it will fetch the nearest scope.
    If no scope is found, it will use the global scope (:meth:`label_scope.global_`).

    If the scope is found and is not global scope, the scope's full name will be prepended to the label,
    i.e., the label will then be formatted as ``{scope}/{label}``.
    Otherwise, there are two cases. Firstly, if label is manually specified, it will be returned directly.
    Secondly, we rely on the global scope to generate the label name, and the scope name will still be prepended.
    The rules can be better explained with the examples below.

    Notes
    -----
    We always recommend specifying the label manually.

    Parameters
    ----------
    label
        The label name to use. If not specified, it will be generated by the scope.
    scope
        The scope to use. If not specified, the nearest scope will be used.

    Examples
    --------
    >>> label1 = auto_label('bar')          # bar, because the scope is global
    >>> label2 = auto_label()               # global/1, because label is not provided
    >>> with label_scope('foo'):
    ...     label3 = auto_label()           # foo/1, because in the scope "foo"
    >>> with label_scope():
    ...     label4 = auto_label()           # param/1, default key is used
    >>> with label_scope('another'):
    ...     label5 = auto_label()           # another/1
    ...     label6 = auto_label('thing')    # another/thing
    ...     label7 = auto_label()           # another/2
    """

    if label is not None:
        # Validate the label name given.
        # The caller might have given a label name that is not valid.
        _validate_label_name(label)

    if scope is not None and not isinstance(scope, label_scope):
        raise TypeError('scope must be an instance of label_scope')

    if scope is None:
        # Auto-fetch the current label space (can be none).
        scope = label_scope.current()

    if label is None:
        if scope is None:
            # NOTE: It's not recommended to use the default namespace because the stable label numbering cannot be guaranteed.
            # However, we allow such usage currently because it's mostly used in evaluator,
            # whose initialization relies on trace, and doesn't need to be reproducible in trial code.
            _logger.warning(
                'Label is not provided, and label scope is also missing. Global numbering will be used. '
                'Note that we always recommend specifying `label=...` manually.',
            )
            # Fake a global namespace.
            scope = label_scope.global_()
        label = scope.next_label()

    if scope is None:
        return label
    else:
        return f'{scope.absolute_scope}/{label}'


def _validate_label_name(name: str) -> None:
    if not isinstance(name, str):
        raise TypeError('label must be a string')
    if '/' in name or '_' in name:
        raise ValueError('label cannot contain underscore (_) or slash (/). Do not use auto_label() if you insist.')
    if name.isdigit():
        _logger.warning('We do not recommend using a label name that is only digits: %s', name)
