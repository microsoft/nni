
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/quantization_bert_glue.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_quantization_bert_glue.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_quantization_bert_glue.py:


Quantize BERT on Task GLUE
==========================

Here we show an effective transformer simulated quantization process that NNI team has tried, and users can use NNI to discover better process

we use the BERT model and the trainer pipeline in the Transformers to do some experiments.
The entire quantization process can be divided into the following steps:

1. Use the BERT-base-uncased model and the trainer pipeline in the transformers to fine-tune the model on the downstream task GLUE.
   From our experience, the final performance of quantization on the finetuned model is
   better than quantization directly on the pre-trained model.
2. Use a specific quantizer to quantize the finetuned model on the GLUE.
   Here we apply QAT, LSQ and PTQ quantizers to quantize the BERT model so that 
   we can compare their performance of the quantized BERT on the GLUE.
   Among them, LSQ and QAT are quantization aware training methods, and PTQ is a post-training quantization method.

During the process of quantizing BERT:

* we use the BERT model and the trainer pipeline in the Transformers to do some experiments.
* we use int8 to quantize Linear layers in the BERT.encoder.

Experiment
----------

Preparation
^^^^^^^^^^^

This section is mainly for fine-tuning model on the downstream task GLUE.
If you are familiar with how to finetune BERT on GLUE dataset, you can skip this section.

1. Load the tokenizer and BERT model from Huggingface transformers.
2. Create a trainer instance to fine-tune the BERT model.

.. note::

    Please set ``dev_mode`` to ``False`` to run this tutorial. Here ``dev_mode`` is ``True`` by default is for generating documents.

.. GENERATED FROM PYTHON SOURCE LINES 40-71

.. code-block:: default


    from pathlib import Path
    import argparse

    import numpy as np

    import torch
    from torch.utils.data import ConcatDataset

    import nni

    from datasets import load_dataset, load_metric
    from transformers import BertTokenizerFast, DataCollatorWithPadding, BertForSequenceClassification, EvalPrediction
    from transformers.trainer import Trainer
    from transformers.training_args import TrainingArguments


    task_name = 'rte'
    finetune_lr = 4e-5
    quant_lr = 1e-5
    quant_method = 'lsq'
    dev_mode = True

    if dev_mode:
        quant_max_epochs = 1
        finetune_max_epochs = 1
    else:
        quant_max_epochs = 10
        finetune_max_epochs = 10









.. GENERATED FROM PYTHON SOURCE LINES 72-73

Load the pre-trained model from the transformers

.. GENERATED FROM PYTHON SOURCE LINES 73-80

.. code-block:: default


    def build_model(pretrained_model_name_or_path: str, task_name: str):
        is_regression = task_name == 'stsb'
        num_labels = 1 if is_regression else (3 if task_name == 'mnli' else 2)
        model = BertForSequenceClassification.from_pretrained(pretrained_model_name_or_path, num_labels=num_labels)
        return model








.. GENERATED FROM PYTHON SOURCE LINES 81-82

Create datasets on the specific task GLUE

.. GENERATED FROM PYTHON SOURCE LINES 82-131

.. code-block:: default


    def prepare_datasets(task_name: str, tokenizer: BertTokenizerFast, cache_dir: str):
        task_to_keys = {
            'cola': ('sentence', None),
            'mnli': ('premise', 'hypothesis'),
            'mrpc': ('sentence1', 'sentence2'),
            'qnli': ('question', 'sentence'),
            'qqp': ('question1', 'question2'),
            'rte': ('sentence1', 'sentence2'),
            'sst2': ('sentence', None),
            'stsb': ('sentence1', 'sentence2'),
            'wnli': ('sentence1', 'sentence2'),
        }
        sentence1_key, sentence2_key = task_to_keys[task_name]

        # used to preprocess the raw data
        def preprocess_function(examples):
            # Tokenize the texts
            args = (
                (examples[sentence1_key],) if sentence2_key is None else (examples[sentence1_key], examples[sentence2_key])
            )
            result = tokenizer(*args, padding=False, max_length=128, truncation=True)

            if 'label' in examples:
                # In all cases, rename the column to labels because the model will expect that.
                result['labels'] = examples['label']
            return result

        raw_datasets = load_dataset('glue', task_name, cache_dir=cache_dir)
        for key in list(raw_datasets.keys()):
            if 'test' in key:
                raw_datasets.pop(key)

        processed_datasets = raw_datasets.map(preprocess_function, batched=True,
                                              remove_columns=raw_datasets['train'].column_names)

        train_dataset = processed_datasets['train']
        if task_name == 'mnli':
            validation_datasets = {
                'validation_matched': processed_datasets['validation_matched'],
                'validation_mismatched': processed_datasets['validation_mismatched']
            }
        else:
            validation_datasets = {
                'validation': processed_datasets['validation']
            }

        return train_dataset, validation_datasets








.. GENERATED FROM PYTHON SOURCE LINES 132-133

Create a trainer instance

.. GENERATED FROM PYTHON SOURCE LINES 133-191

.. code-block:: default


    # .. note::

    #     Please set ``is_trace`` to ``False`` to fine-tune the BERT model and set ``is_trace`` to ``True``
    #     When you need to create a traced trainer for model quantization.

    def prepare_traced_trainer(model, load_best_model_at_end=False, is_trace=False):
        is_regression = task_name == 'stsb'
        metric = load_metric('glue', task_name)

        def compute_metrics(p: EvalPrediction):
            preds = p.predictions[0] if isinstance(p.predictions, tuple) else p.predictions
            preds = np.squeeze(preds) if is_regression else np.argmax(preds, axis=1)
            result = metric.compute(predictions=preds, references=p.label_ids)
            result['default'] = result.get('f1', result.get('accuracy', 0.))
            return result

        tokenizer = BertTokenizerFast.from_pretrained('bert-base-uncased')
        train_dataset, validation_datasets = prepare_datasets(task_name, tokenizer, '')
        merged_validation_dataset = ConcatDataset([d for d in validation_datasets.values()]) # type: ignore
        data_collator = DataCollatorWithPadding(tokenizer)
        training_args = TrainingArguments(output_dir='./output/trainer',
                                          do_train=True,
                                          do_eval=True,
                                          evaluation_strategy='steps',
                                          per_device_train_batch_size=128, #128,
                                          per_device_eval_batch_size=128, #128,
                                          num_train_epochs=finetune_max_epochs,
                                          dataloader_num_workers=12,
                                          save_strategy='steps',
                                          save_total_limit=1,
                                          metric_for_best_model='default',
                                          greater_is_better=True,
                                          seed=1024,
                                          load_best_model_at_end=load_best_model_at_end,)
        if is_trace:
            training_args.learning_rate = quant_lr
            trainer = nni.trace(Trainer)(model=model,
                                        args=training_args,
                                        data_collator=data_collator,
                                        train_dataset=train_dataset,
                                        eval_dataset=merged_validation_dataset,
                                        tokenizer=tokenizer,
                                        compute_metrics=compute_metrics,
                                        )
        else:
            training_args.learning_rate = finetune_lr
            trainer = Trainer(model=model,
                             args=training_args,
                             data_collator=data_collator,
                             train_dataset=train_dataset,
                             eval_dataset=merged_validation_dataset,
                             tokenizer=tokenizer,
                             compute_metrics=compute_metrics,
                             )

        return trainer








.. GENERATED FROM PYTHON SOURCE LINES 192-193

Create the finetuned model

.. GENERATED FROM PYTHON SOURCE LINES 193-204

.. code-block:: default


    def build_finetuning_model(state_dict_path: str, is_trace=False):
        model = build_model('bert-base-uncased', task_name)
        if Path(state_dict_path).exists():
            model.load_state_dict(torch.load(state_dict_path))
        else:
            trainer = prepare_traced_trainer(model, True, is_trace)
            trainer.train()
            torch.save(model.state_dict(), state_dict_path)
        return model








.. GENERATED FROM PYTHON SOURCE LINES 205-218

Quantization
^^^^^^^^^^^^
After fine-tuning the BERT model on the specific task GLUE, a specific quantizer instsance can be created
to process quantization aware training or post-training quantization with BERT on the GLUE.

The entire quantization process can be devided into the following steps:

1. Call ``build_finetuning_model`` to load or fine-tune the BERT model on a specific task GLUE
2. Call ``prepare_traced_trainer`` and set ``is_trace`` to ``True`` to create a traced trainer instance for model quantization
3. Call the TransformersEvaluator to create an evaluator instance
4. Use the defined config_list and evaluator to create a quantizer instance
5. Define ``max_steps`` or ``max_epochs``. Note that ``max_steps`` and ``max_epochs`` cannot be None at the same time.
6. Call ``quantizer.compress(max_steps, max_epochs)`` to execute the simulated quantization process

.. GENERATED FROM PYTHON SOURCE LINES 218-266

.. code-block:: default


    import nni
    from nni.contrib.compression.quantization import QATQuantizer, LsqQuantizer, PtqQuantizer
    from nni.contrib.compression.utils import TransformersEvaluator

    def fake_quantize():
        config_list = [{
            'op_types': ['Linear'],
            'op_names_re': ['bert.encoder.layer.{}'.format(i) for i in range(12)],
            'target_names': ['weight', '_output_'],
            'quant_dtype': 'int8',
            'quant_scheme': 'affine',
            'granularity': 'default',
        }]

        # create a finetune model
        Path('./output/bert_finetuned/').mkdir(parents=True, exist_ok=True)
        model: torch.nn.Module = build_finetuning_model(f'./output/bert_finetuned/{task_name}.bin', is_trace=False) # type: ignore
        traced_trainer = prepare_traced_trainer(model, is_trace=True)
        evaluator = TransformersEvaluator(traced_trainer)
        if quant_method == 'lsq':
            quantizer = LsqQuantizer(model, config_list, evaluator)
            model, calibration_config = quantizer.compress(max_steps=None, max_epochs=quant_max_epochs)
        elif quant_method == 'qat':
            quantizer = QATQuantizer(model, config_list, evaluator, 1000)
            model, calibration_config = quantizer.compress(max_steps=None, max_epochs=quant_max_epochs)
        elif quant_method == 'ptq':
            quantizer = PtqQuantizer(model, config_list, evaluator)
            model, calibration_config = quantizer.compress(max_steps=1, max_epochs=None)
        else:
            raise ValueError(f"quantization method {quant_method} is not supported")
        print(calibration_config)
        # evaluate the performance of the fake quantize model
        quantizer.evaluator.bind_model(model, quantizer._get_param_names_map())
        print(quantizer.evaluator.evaluate())

    def evaluate():
        model = build_finetuning_model(f'./output/bert_finetuned/{task_name}.bin', is_trace=False)
        trainer = prepare_traced_trainer(model, is_trace=False)
        metrics = trainer.evaluate()
        print(f"Evaluate metrics={metrics}")


    if __name__ == "__main__":
        fake_quantize()
        evaluate()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Some weights of the model checkpoint at bert-base-uncased were not used when initializing BertForSequenceClassification: ['cls.predictions.decoder.weight', 'cls.predictions.bias', 'cls.predictions.transform.dense.bias', 'cls.seq_relationship.bias', 'cls.predictions.transform.LayerNorm.bias', 'cls.predictions.transform.LayerNorm.weight', 'cls.seq_relationship.weight', 'cls.predictions.transform.dense.weight']
    - This IS expected if you are initializing BertForSequenceClassification from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
    - This IS NOT expected if you are initializing BertForSequenceClassification from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
    Some weights of BertForSequenceClassification were not initialized from the model checkpoint at bert-base-uncased and are newly initialized: ['classifier.weight', 'classifier.bias']
    You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
    /home/xinzhang3/bug_fix/nni/examples/tutorials/quantization_bert_glue.py:141: FutureWarning: load_metric is deprecated and will be removed in the next major version of datasets. Use 'evaluate.load' instead, from the new library ðŸ¤— Evaluate: https://huggingface.co/docs/evaluate
      metric = load_metric('glue', task_name)
    Found cached dataset glue (/home/xinzhang3/.cache/huggingface/datasets/glue/rte/1.0.0/dacbe3125aa31d7f70367a07a8a9e72a5a0bfeb5fc42e75c9db75b96da6053ad)
      0%|          | 0/3 [00:00<?, ?it/s]    100%|##########| 3/3 [00:00<00:00, 1304.47it/s]
    Loading cached processed dataset at /home/xinzhang3/.cache/huggingface/datasets/glue/rte/1.0.0/dacbe3125aa31d7f70367a07a8a9e72a5a0bfeb5fc42e75c9db75b96da6053ad/cache-e5de121dc04ebc15.arrow
    Loading cached processed dataset at /home/xinzhang3/.cache/huggingface/datasets/glue/rte/1.0.0/dacbe3125aa31d7f70367a07a8a9e72a5a0bfeb5fc42e75c9db75b96da6053ad/cache-7d912fed26ab6913.arrow
    trainer.optimzer is not wrapped by nni.trace, or trainer.optimzer is None, will using huggingface default optimizer.
    /anaconda/envs/bug_fix/lib/python3.9/site-packages/transformers/optimization.py:391: FutureWarning: This implementation of AdamW is deprecated and will be removed in a future version. Use the PyTorch implementation torch.optim.AdamW instead, or set `no_deprecation_warning=True` to disable this warning
      warnings.warn(
    trainer.lr_scheduler is not wrapped by nni.trace, or trainer.lr_scheduler is None, will using huggingface default lr_scheduler.
      0%|          | 0/20 [00:00<?, ?it/s]      5%|5         | 1/20 [00:01<00:35,  1.85s/it]     10%|#         | 2/20 [00:02<00:21,  1.18s/it]     15%|#5        | 3/20 [00:03<00:16,  1.03it/s]     20%|##        | 4/20 [00:03<00:13,  1.16it/s]     25%|##5       | 5/20 [00:04<00:12,  1.23it/s]     30%|###       | 6/20 [00:05<00:10,  1.29it/s]     35%|###5      | 7/20 [00:06<00:09,  1.32it/s]     40%|####      | 8/20 [00:07<00:10,  1.14it/s]     45%|####5     | 9/20 [00:07<00:09,  1.21it/s]     50%|#####     | 10/20 [00:08<00:07,  1.27it/s]     55%|#####5    | 11/20 [00:09<00:06,  1.31it/s]     60%|######    | 12/20 [00:10<00:05,  1.33it/s]     65%|######5   | 13/20 [00:10<00:05,  1.35it/s]     70%|#######   | 14/20 [00:11<00:04,  1.37it/s]     75%|#######5  | 15/20 [00:12<00:03,  1.38it/s]     80%|########  | 16/20 [00:12<00:02,  1.39it/s]     85%|########5 | 17/20 [00:13<00:02,  1.39it/s]     90%|######### | 18/20 [00:14<00:01,  1.40it/s]     95%|#########5| 19/20 [00:15<00:00,  1.40it/s]    100%|##########| 20/20 [00:15<00:00,  1.65it/s]                                                   {'train_runtime': 15.5158, 'train_samples_per_second': 160.482, 'train_steps_per_second': 1.289, 'train_loss': 0.07080812454223633, 'epoch': 1.0}
    100%|##########| 20/20 [00:15<00:00,  1.65it/s]    100%|##########| 20/20 [00:15<00:00,  1.29it/s]
    defaultdict(<class 'dict'>, {'bert.encoder.layer.3.attention.self.query': {'weight': {'scale': tensor(0.0060, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7612, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7612, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1530, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(19.4248, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-19.4248, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.7.attention.self.query': {'weight': {'scale': tensor(0.0061, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7753, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7753, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1764, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(22.4064, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-22.4064, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.6.attention.output.dense': {'weight': {'scale': tensor(0.0045, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5704, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5704, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0439, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(5.5798, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-5.5798, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.11.attention.self.key': {'weight': {'scale': tensor(0.0063, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7968, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7968, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1653, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(20.9940, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-20.9940, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.1.attention.self.key': {'weight': {'scale': tensor(0.0059, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7492, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7492, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1582, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(20.0973, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-20.0973, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.4.intermediate.dense': {'weight': {'scale': tensor(0.0057, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7248, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7248, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.3526, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(44.7757, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-44.7757, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.10.output.dense': {'weight': {'scale': tensor(0.0053, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6764, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6764, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1114, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(14.1503, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-14.1503, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.6.attention.self.key': {'weight': {'scale': tensor(0.0061, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7696, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7696, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1765, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(22.4174, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-22.4174, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.4.attention.output.dense': {'weight': {'scale': tensor(0.0045, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5668, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5668, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0453, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(5.7556, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-5.7556, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.6.output.dense': {'weight': {'scale': tensor(0.0053, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6730, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6730, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0434, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(5.5077, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-5.5077, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.8.intermediate.dense': {'weight': {'scale': tensor(0.0055, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6957, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6957, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.2804, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(35.6141, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-35.6141, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.6.attention.self.value': {'weight': {'scale': tensor(0.0048, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6067, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6067, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0950, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(12.0609, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-12.0609, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.2.attention.self.key': {'weight': {'scale': tensor(0.0064, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.8069, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.8069, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1595, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(20.2543, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-20.2543, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.0.attention.self.value': {'weight': {'scale': tensor(0.0040, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5113, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5113, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0653, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(8.2876, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-8.2876, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.0.intermediate.dense': {'weight': {'scale': tensor(0.0052, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6625, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6625, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.4257, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(54.0653, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-54.0653, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.7.output.dense': {'weight': {'scale': tensor(0.0052, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6575, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6575, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0451, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(5.7306, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-5.7306, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.2.intermediate.dense': {'weight': {'scale': tensor(0.0055, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7031, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7031, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.3703, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(47.0272, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-47.0272, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.5.attention.self.value': {'weight': {'scale': tensor(0.0049, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6213, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6213, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0928, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(11.7824, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-11.7824, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.9.output.dense': {'weight': {'scale': tensor(0.0053, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6784, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6784, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0504, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(6.4027, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-6.4027, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.8.attention.self.query': {'weight': {'scale': tensor(0.0062, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7899, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7899, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1725, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(21.9090, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-21.9090, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.8.attention.self.key': {'weight': {'scale': tensor(0.0062, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7858, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7858, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1662, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(21.1102, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-21.1102, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.10.attention.output.dense': {'weight': {'scale': tensor(0.0047, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5935, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5935, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0579, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(7.3571, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-7.3571, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.9.attention.output.dense': {'weight': {'scale': tensor(0.0046, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5834, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5834, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0356, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(4.5173, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-4.5173, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.8.attention.output.dense': {'weight': {'scale': tensor(0.0047, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5988, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5988, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0338, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(4.2935, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-4.2935, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.5.attention.self.query': {'weight': {'scale': tensor(0.0061, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7741, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7741, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1792, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(22.7578, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-22.7578, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.11.attention.self.query': {'weight': {'scale': tensor(0.0064, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.8101, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.8101, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1762, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(22.3811, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-22.3811, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.9.attention.self.key': {'weight': {'scale': tensor(0.0065, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.8249, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.8249, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1608, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(20.4275, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-20.4275, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.4.attention.self.query': {'weight': {'scale': tensor(0.0059, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7535, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7535, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1581, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(20.0825, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-20.0825, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.1.attention.self.value': {'weight': {'scale': tensor(0.0040, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5054, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5054, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0806, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(10.2407, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-10.2407, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.6.intermediate.dense': {'weight': {'scale': tensor(0.0057, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7212, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7212, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.3242, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(41.1728, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-41.1728, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.2.attention.self.query': {'weight': {'scale': tensor(0.0066, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.8331, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.8331, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1653, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(20.9909, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-20.9909, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.10.attention.self.key': {'weight': {'scale': tensor(0.0064, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.8180, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.8180, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1669, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(21.1967, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-21.1967, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.1.intermediate.dense': {'weight': {'scale': tensor(0.0055, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7011, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7011, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.3552, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(45.1050, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-45.1050, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.2.attention.self.value': {'weight': {'scale': tensor(0.0039, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.4905, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.4905, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0787, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(9.9966, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-9.9966, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.2.output.dense': {'weight': {'scale': tensor(0.0052, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6643, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6643, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0519, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(6.5857, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-6.5857, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.3.output.dense': {'weight': {'scale': tensor(0.0053, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6783, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6783, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0587, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(7.4608, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-7.4608, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.11.output.dense': {'weight': {'scale': tensor(0.0051, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6420, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6420, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0411, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(5.2177, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-5.2177, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.9.intermediate.dense': {'weight': {'scale': tensor(0.0056, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7097, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7097, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.2696, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(34.2431, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-34.2431, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.9.attention.self.query': {'weight': {'scale': tensor(0.0065, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.8237, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.8237, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1706, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(21.6719, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-21.6719, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.1.output.dense': {'weight': {'scale': tensor(0.0052, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6617, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6617, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0603, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(7.6590, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-7.6590, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.3.attention.self.key': {'weight': {'scale': tensor(0.0060, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7610, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7610, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1536, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(19.5068, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-19.5068, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.5.attention.output.dense': {'weight': {'scale': tensor(0.0046, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5851, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5851, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0444, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(5.6446, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-5.6446, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.10.attention.self.value': {'weight': {'scale': tensor(0.0049, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6282, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6282, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0968, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(12.2933, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-12.2933, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.7.intermediate.dense': {'weight': {'scale': tensor(0.0055, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6980, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6980, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.2975, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(37.7791, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-37.7791, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.0.attention.output.dense': {'weight': {'scale': tensor(0.0039, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.4927, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.4927, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0307, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(3.9023, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-3.9023, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.0.attention.self.query': {'weight': {'scale': tensor(0.0060, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7603, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7603, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1317, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(16.7232, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-16.7232, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.11.attention.self.value': {'weight': {'scale': tensor(0.0055, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7004, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7004, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1125, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(14.2920, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-14.2920, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.5.intermediate.dense': {'weight': {'scale': tensor(0.0057, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7204, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7204, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.3190, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(40.5128, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-40.5128, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.9.attention.self.value': {'weight': {'scale': tensor(0.0049, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6197, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6197, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0956, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(12.1416, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-12.1416, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.4.output.dense': {'weight': {'scale': tensor(0.0054, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6856, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6856, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0492, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(6.2487, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-6.2487, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.7.attention.self.value': {'weight': {'scale': tensor(0.0046, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5904, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5904, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0861, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(10.9348, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-10.9348, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.3.attention.self.value': {'weight': {'scale': tensor(0.0043, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5441, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5441, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0836, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(10.6220, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-10.6220, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.1.attention.output.dense': {'weight': {'scale': tensor(0.0039, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.4901, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.4901, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0282, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(3.5869, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-3.5869, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.11.attention.output.dense': {'weight': {'scale': tensor(0.0052, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6608, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6608, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0735, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(9.3305, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-9.3305, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.8.attention.self.value': {'weight': {'scale': tensor(0.0050, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6374, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6374, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0985, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(12.5155, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-12.5155, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.10.intermediate.dense': {'weight': {'scale': tensor(0.0055, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6949, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6949, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1405, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(17.8444, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-17.8444, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.4.attention.self.key': {'weight': {'scale': tensor(0.0059, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7464, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7464, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1548, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(19.6655, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-19.6655, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.1.attention.self.query': {'weight': {'scale': tensor(0.0059, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7511, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7511, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1531, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(19.4500, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-19.4500, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.0.attention.self.key': {'weight': {'scale': tensor(0.0059, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7431, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7431, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1455, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(18.4832, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-18.4832, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.4.attention.self.value': {'weight': {'scale': tensor(0.0049, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6184, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6184, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0964, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(12.2427, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-12.2427, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.6.attention.self.query': {'weight': {'scale': tensor(0.0060, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7637, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7637, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1762, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(22.3795, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-22.3795, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.3.attention.output.dense': {'weight': {'scale': tensor(0.0040, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5037, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5037, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0323, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(4.1053, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-4.1053, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.5.attention.self.key': {'weight': {'scale': tensor(0.0061, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7691, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7691, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1821, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(23.1277, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-23.1277, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.11.intermediate.dense': {'weight': {'scale': tensor(0.0055, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7009, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7009, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.2698, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(34.2701, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-34.2701, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.0.output.dense': {'weight': {'scale': tensor(0.0050, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6378, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6378, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1169, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(14.8435, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-14.8435, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.3.intermediate.dense': {'weight': {'scale': tensor(0.0056, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7146, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7146, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.3379, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(42.9079, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-42.9079, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.7.attention.output.dense': {'weight': {'scale': tensor(0.0044, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.5593, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.5593, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0373, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(4.7343, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-4.7343, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.8.output.dense': {'weight': {'scale': tensor(0.0052, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6586, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6586, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0471, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(5.9795, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-5.9795, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.10.attention.self.query': {'weight': {'scale': tensor(0.0064, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.8179, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.8179, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1737, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(22.0542, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-22.0542, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.7.attention.self.key': {'weight': {'scale': tensor(0.0061, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.7759, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.7759, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.1789, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(22.7172, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-22.7172, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.2.attention.output.dense': {'weight': {'scale': tensor(0.0037, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.4665, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.4665, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0301, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(3.8238, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-3.8238, grad_fn=<ToCopyBackward0>)}}, 'bert.encoder.layer.5.output.dense': {'weight': {'scale': tensor(0.0054, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(0.6807, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-0.6807, grad_fn=<ToCopyBackward0>)}, '_output_0': {'scale': tensor(0.0478, grad_fn=<ToCopyBackward0>), 'zero_point': tensor(0.), 'quant_dtype': 'int8', 'quant_scheme': 'affine', 'quant_bits': 8, 'tracked_max': tensor(6.0759, grad_fn=<ToCopyBackward0>), 'tracked_min': tensor(-6.0759, grad_fn=<ToCopyBackward0>)}}})
      0%|          | 0/3 [00:00<?, ?it/s]     67%|######6   | 2/3 [00:00<00:00,  8.71it/s]    100%|##########| 3/3 [00:00<00:00,  7.99it/s]
    Evaluation function returns a dict metric without key `default`,will return None as the model evaluation metric value.
    (None, {'eval_loss': 1.5372109413146973, 'eval_accuracy': 0.6353790613718412, 'eval_default': 0.6353790613718412, 'eval_runtime': 0.9313, 'eval_samples_per_second': 297.432, 'eval_steps_per_second': 3.221})
    Some weights of the model checkpoint at bert-base-uncased were not used when initializing BertForSequenceClassification: ['cls.predictions.decoder.weight', 'cls.predictions.bias', 'cls.predictions.transform.dense.bias', 'cls.seq_relationship.bias', 'cls.predictions.transform.LayerNorm.bias', 'cls.predictions.transform.LayerNorm.weight', 'cls.seq_relationship.weight', 'cls.predictions.transform.dense.weight']
    - This IS expected if you are initializing BertForSequenceClassification from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
    - This IS NOT expected if you are initializing BertForSequenceClassification from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
    Some weights of BertForSequenceClassification were not initialized from the model checkpoint at bert-base-uncased and are newly initialized: ['classifier.weight', 'classifier.bias']
    You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
    Found cached dataset glue (/home/xinzhang3/.cache/huggingface/datasets/glue/rte/1.0.0/dacbe3125aa31d7f70367a07a8a9e72a5a0bfeb5fc42e75c9db75b96da6053ad)
      0%|          | 0/3 [00:00<?, ?it/s]    100%|##########| 3/3 [00:00<00:00, 1174.33it/s]
    Loading cached processed dataset at /home/xinzhang3/.cache/huggingface/datasets/glue/rte/1.0.0/dacbe3125aa31d7f70367a07a8a9e72a5a0bfeb5fc42e75c9db75b96da6053ad/cache-e5de121dc04ebc15.arrow
    Loading cached processed dataset at /home/xinzhang3/.cache/huggingface/datasets/glue/rte/1.0.0/dacbe3125aa31d7f70367a07a8a9e72a5a0bfeb5fc42e75c9db75b96da6053ad/cache-7d912fed26ab6913.arrow
      0%|          | 0/3 [00:00<?, ?it/s]     67%|######6   | 2/3 [00:00<00:00, 11.07it/s]    100%|##########| 3/3 [00:00<00:00,  9.01it/s]
    Evaluate metrics={'eval_loss': 1.811340570449829, 'eval_accuracy': 0.6389891696750902, 'eval_default': 0.6389891696750902, 'eval_runtime': 0.8606, 'eval_samples_per_second': 321.865, 'eval_steps_per_second': 3.486}




.. GENERATED FROM PYTHON SOURCE LINES 267-304

Result
------
We experimented with PTQ, LSQ, and QAT algorithms on the MNLI, QNLI, QQP and  MRPC datasets respectively on an A100, and the experimental results are as follows

..list-table:: Quantize Bert-base-uncased on MNLI, QNLI, MRPC and QQP datasets.
    :header-rows: 1
    :widths: auto

    * - Quant Method
      - MNLI
      - QNLI
      - MRPC
      - QQP
    * - Metrics
      - ACC
      - ACC
      - F1
      - F1
    * - Baseline
      - 85.04
      - 91.67
      - 87.69
      - 88.42
    * - LSQ
      - 84.34
      - 91.69
      - 89.9
      - 88.16
    * - QAT
      - 83.68
      - 90.52
      - 89.16
      - 87.62
    * - PTQ
      - 76.37
      - 67.67
      - 74.79
      - 84.82


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  25.836 seconds)


.. _sphx_glr_download_tutorials_quantization_bert_glue.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: quantization_bert_glue.py <quantization_bert_glue.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: quantization_bert_glue.ipynb <quantization_bert_glue.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
